# OT Learning Hub â€“ RevampedÂ v1.1  
# =====================================
# ğŸ“ Improved project tree
# (copyâ€‘paste the whole snippet into a fresh folder)

```text
ğŸ“‚ ot_learning_site/
â”‚  app.py
â”‚  requirements.txt
â”‚  README.md
â”‚
â”œâ”€ services/
â”‚   â”œâ”€ __init__.py
â”‚   â”œâ”€ pdf_to_markdown.py
â”‚   â”œâ”€ summarize.py
â”‚   â”œâ”€ keywords.py
â”‚   â””â”€ ocr_figures.py
â”‚
â”œâ”€ templates/
â”‚   â”œâ”€ base.html
â”‚   â”œâ”€ index.html
â”‚   â””â”€ result.html
â”‚
â””â”€ static/
    â”œâ”€ css/style.css
    â””â”€ js/main.js
```

---

### requirements.txt
```text
Flask==3.0.2
PyMuPDF==1.24.0
pdf2image==1.17.0
pytesseract==0.3.10
Pillow==10.3.0
transformers==4.42.0
sentencepiece==0.2.0
torch==2.2.2
nltk==3.8.1
```

---

### README.md (ğŸ” åŸå› ã¨ä¿®æ­£ãƒã‚¤ãƒ³ãƒˆã¾ã¨ã‚)
```markdown
## â— å¤‰æ›ãŒå‹•ã‹ãªã‹ã£ãŸä¸»åŸå› 
1. **PyMuPDF API èª¤ç”¨** â€“ `fitz.TextBlock` ã¯å­˜åœ¨ã—ãªã„ã‚¯ãƒ©ã‚¹ã§ã—ãŸã€‚
2. **ç”»åƒ size åˆ¤å®š** â€“ `extract_image()` ã®æˆ»ã‚Š dict ã« `size` ã‚­ãƒ¼ã¯ç„¡ãã€`len(img['image'])` ã§åˆ¤å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
3. **å·¨å¤§ãƒ†ã‚­ã‚¹ãƒˆã®è¦ç´„** â€“ BART ã®ãƒˆãƒ¼ã‚¯ãƒ³åˆ¶é™ã‚’è¶…ãˆã‚‹ã¨ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã€‚ãƒãƒ£ãƒ³ã‚¯åŒ–ã§è§£æ±ºã€‚

## ğŸ©¹ ä¸»ãªæ”¹å–„
- PDF â†’ Markdown ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’å…¨é¢å†å®Ÿè£…ï¼ˆ2â€‘pass è§£æã§è¦‹å‡ºã—æŠ½å‡ºï¼‰ã€‚
- ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ã¨ãƒ¦ãƒ¼ã‚¶å‘ã‘ flash ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ ã€‚
- UI ã‚’ Tailwind + Lucide icons ã§ãƒªãƒ•ã‚¡ã‚¤ãƒ³ã€‚
```

---

### app.py
```python
from flask import Flask, render_template, request, send_file, redirect, url_for, flash
from werkzeug.utils import secure_filename
from pathlib import Path
import uuid, logging
from services.pdf_to_markdown import convert_pdf

# ---------- paths & config ----------
BASE_DIR = Path(__file__).resolve().parent
UPLOAD_DIR = BASE_DIR / "uploads"
OUTPUT_DIR = BASE_DIR / "outputs"
for p in (UPLOAD_DIR, OUTPUT_DIR):
    p.mkdir(exist_ok=True)
ALLOWED_EXT = {".pdf"}

# ---------- logging ----------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.FileHandler(BASE_DIR / "server.log"), logging.StreamHandler()],
)
logger = logging.getLogger(__name__)

# ---------- app ----------
app = Flask(__name__)
app.config["SECRET_KEY"] = "changeâ€‘meâ€‘inâ€‘prod"

def allowed(filename: str) -> bool:
    return Path(filename).suffix.lower() in ALLOWED_EXT

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/upload", methods=["POST"])
def upload():
    pdf = request.files.get("pdf")
    if not pdf or pdf.filename == "":
        flash("PDF ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚", "warning")
        return redirect(url_for("index"))
    if not allowed(pdf.filename):
        flash("PDF å½¢å¼ã®ã¿å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚", "danger")
        return redirect(url_for("index"))

    # ---------- save ----------
    file_id = uuid.uuid4().hex
    pdf_path = UPLOAD_DIR / f"{file_id}.pdf"
    pdf.save(pdf_path)
    logger.info("Uploaded %s", pdf_path.name)

    # ---------- convert ----------
    try:
        md_text = convert_pdf(pdf_path)
    except Exception as e:
        logger.exception("Conversion failed: %s", e)
        flash("å¤‰æ›ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚PDF ãŒç ”ç©¶è«–æ–‡å½¢å¼ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚", "danger")
        return redirect(url_for("index"))

    md_path = OUTPUT_DIR / f"{file_id}.md"
    md_path.write_text(md_text, encoding="utf-8")

    flash("å¤‰æ›æˆåŠŸï¼", "success")
    return render_template("result.html", markdown=md_text, download=url_for("download_md", file_id=file_id))

@app.route("/download/<file_id>")
def download_md(file_id):
    md_path = OUTPUT_DIR / f"{file_id}.md"
    if md_path.exists():
        return send_file(md_path, as_attachment=True)
    flash("ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚", "danger")
    return redirect(url_for("index"))

if __name__ == "__main__":
    app.run(debug=True, port=5000)
```

---

### services/__init__.py
```python
# Just to mark the folder as a module.
```

---

### services/pdf_to_markdown.py
```python
"""PDF â†’ Markdown conversion pipeline (2â€‘pass heading detection)."""
from pathlib import Path
import statistics, textwrap, logging
import fitz  # PyMuPDF
from .summarize import summarize_text
from .keywords import extract_keywords
from .ocr_figures import extract_figure_captions

logger = logging.getLogger(__name__)

# ---------- helpers ----------

def _collect_font_sizes(doc):
    sizes = []
    for page in doc:
        for block in page.get_text("dict").get("blocks", []):
            if block.get("type") != 0:
                continue
            for line in block.get("lines", []):
                for span in line.get("spans", []):
                    sizes.append(span["size"])
    return sizes or [11]


def _text_from_block(block_dict):
    return "".join(span["text"] for line in block_dict.get("lines", []) for span in line.get("spans", [])).strip()

# ---------- main ----------

def convert_pdf(pdf_path: Path) -> str:
    logger.info("Converting %s", pdf_path)
    doc = fitz.open(pdf_path)

    # passâ€‘1: font stats
    body_size = statistics.mode(round(s) for s in _collect_font_sizes(doc))  # most common size
    heading_threshold = body_size + 1  # crude heuristic
    logger.info("Body font â‰ˆ %s pt; heading â‰¥ %s pt", body_size, heading_threshold)

    # passâ€‘2: sectioning
    sections = []
    current = {"title": "", "content": ""}

    for page in doc:
        for block in page.get_text("dict").get("blocks", []):
            if block.get("type") != 0:
                continue
            txt = _text_from_block(block)
            if not txt:
                continue
            span_size = block["lines"][0]["spans"][0]["size"]
            if span_size >= heading_threshold and len(txt) < 120:
                if current["title"] or current["content"]:
                    sections.append(current)
                current = {"title": txt, "content": ""}
            else:
                current["content"] += " " + txt
    if current["title"] or current["content"]:
        sections.append(current)

    # Markdown build
    md_lines = []
    full_text = " ".join(sec["content"] for sec in sections)

    # summary & keywords
    summary = summarize_text(full_text)
    md_lines.append("# è«–æ–‡è¦ç´„\n" + summary + "\n")
    md_lines.append("**ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:** " + ", ".join(extract_keywords(full_text)) + "\n\n")

    for sec in sections:
        if sec["title"]:
            md_lines.append(f"## {sec['title']}")
        md_lines.append(textwrap.fill(sec["content"].strip(), 120))
        md_lines.append("\n")

    # figures
    captions = extract_figure_captions(pdf_path)
    if captions:
        md_lines.append("---\n## é‡è¦å›³è¡¨ OCR ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³\n")
        md_lines.extend(f"- {c}" for c in captions)

    return "\n".join(md_lines)
```

---

### services/summarize.py
```python
import nltk, textwrap, logging
from transformers import pipeline
nltk.download("punkt", quiet=True)
logger = logging.getLogger(__name__)

try:
    _summarizer = pipeline("summarization", model="facebook/bart-large-cnn", device_map="auto")
except Exception as e:
    logger.warning("transformers pipeline unavailable (%s) â€“ falling back to naive summarizer", e)
    _summarizer = None


def summarize_text(text: str, max_words: int = 120):
    if not text:
        return "(å†…å®¹ãŒç©ºã§ã™)"
    if _summarizer:
        # chunk to avoid token limit
        chunks = nltk.tokenize.sent_tokenize(text)
        half = len(chunks) // 2 or 1
        head = " ".join(chunks[:half])
        return _summarizer(head)[0]["summary_text"]
    # fallback: first few sentences
    return " ".join(chunks[:3])
```

---

### services/keywords.py
```python
import nltk, re
from collections import Counter
nltk.download("stopwords", quiet=True)
STOP = set(nltk.corpus.stopwords.words("english")) | set("ã® ã“ã¨ ãªã© ã¾ãŸ ãŸã‚ ãã‚Œ ã“ã‚Œ ãã®".split())

def extract_keywords(text: str, n: int = 8):
    words = re.findall(r"[\wä¸€-é¾¥]{2,}", text.lower())
    cnt = Counter(w for w in words if w not in STOP)
    return [w for w, _ in cnt.most_common(n)]
```

---

### services/ocr_figures.py
```python
from pathlib import Path
import fitz, tempfile
from PIL import Image
import pytesseract, logging

logger = logging.getLogger(__name__)


def extract_figure_captions(pdf_path: Path, max_images: int = 5):
    doc = fitz.open(pdf_path)
    captions = []
    for page in doc:
        for img in page.get_images(full=True):
            xref = img[0]
            base = doc.extract_image(xref)
            if len(base["image"]) < 50_000:
                continue
            with tempfile.NamedTemporaryFile(suffix=".png", delete=True) as tmp:
                tmp.write(base["image"])
                tmp.flush()
                cap = pytesseract.image_to_string(Image.open(tmp.name), lang="eng+jpn").strip()
                if cap:
                    captions.append(cap)
            if len(captions) >= max_images:
                return captions
    return captions
```

---

### templates/base.html
```html
<!DOCTYPE html>
<html lang="ja" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OT Learning Hub</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" />
</head>
<body class="min-h-screen bg-gradient-to-br from-sky-50 to-indigo-100 flex flex-col">
  <header class="shadow-sm bg-white/80 backdrop-blur sticky top-0 z-50">
    <div class="max-w-5xl mx-auto px-6 py-4 flex items-center gap-3">
      <i data-lucide="book-open" class="w-6 h-6 text-indigo-600"></i>
      <span class="text-xl font-semibold tracking-wide text-slate-800">OT Learning Hub</span>
    </div>
  </header>
  <main class="flex-grow container max-w-5xl mx-auto px-6 py-10">
    {% with msgs = get_flashed_messages(with_categories=true) %}
    {% if msgs %}
      <ul class="space-y-2 mb-6">
        {% for cat, msg in msgs %}
          <li class="px-4 py-2 rounded-lg {{ 'bg-green-100 text-green-800' if cat=='success' else ('bg-red-100 text-red-800' if cat=='danger' else 'bg-yellow-100 text-yellow-800') }}">{{ msg }}</li>
        {% endfor %}
      </ul>
    {% endif %}
    {% endwith %}
    {% block content %}{% endblock %}
  </main>
  <footer class="text-center text-xs py-6 text-slate-600">Â© {{ now.year }} OT Learning Hub</footer>
  <script>lucide.createIcons();</script>
</body>
</html>
```

---

### templates/index.html
```html
{% extends 'base.html' %}
{% block content %}
<section class="bg-white/90 backdrop-blur shadow-xl rounded-3xl p-10">
  <h2 class="text-2xl font-semibold mb-6 flex items-center gap-2"><i data-lucide="upload"></i> å­¦è¡“ PDF â†’ Markdown å¤‰æ›</h2>
  <form action="{{ url_for('upload') }}" method="post" enctype="multipart/form-data" class="space-y-4">
    <input name="pdf" type="file" accept="application/pdf" required class="file:mr-4 file:px-4 file:py-2 file:rounded-lg file:border-0 file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 text-sm text-slate-700" />
    <button type="submit" class="inline-flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg shadow-md"><i data-lucide="play"></i> å¤‰æ›å®Ÿè¡Œ</button>
  </form>
</section>
{% endblock %}
```

---

### templates/result.html
```html
{% extends 'base.html' %}
{% block content %}
<article class="prose max-w-none bg-white/90 backdrop-blur p-8 rounded-3xl shadow-xl">
  <h2 class="flex items-center gap-2"><i data-lucide="file-text"></i> å¤‰æ›çµæœ</h2>
  <p class="mb-4">
    <a href="{{ download }}" class="text-indigo-600 hover:underline flex items-center gap-1"><i data-lucide="download"></i> Markdown ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</a>
  </p>
  <pre class="whitespace-pre-wrap overflow-x-auto bg-slate-100/80 p-4 rounded-xl">{{ markdown }}</pre>
</article>
{% endblock %}
```

---

### static/css/style.css
```css
body {font-family: "Inter", "Noto Sans JP", sans-serif;}
```

---

### static/js/main.js
```js
// Reserved for future interactive features.
```

---

```
# â¬†ï¸ END OF FILES
```
