# OT Learning Hub – Revamped v1.1  
# =====================================
# 📁 Improved project tree
# (copy‑paste the whole snippet into a fresh folder)

```text
📂 ot_learning_site/
│  app.py
│  requirements.txt
│  README.md
│
├─ services/
│   ├─ __init__.py
│   ├─ pdf_to_markdown.py
│   ├─ summarize.py
│   ├─ keywords.py
│   └─ ocr_figures.py
│
├─ templates/
│   ├─ base.html
│   ├─ index.html
│   └─ result.html
│
└─ static/
    ├─ css/style.css
    └─ js/main.js
```

---

### requirements.txt
```text
Flask==3.0.2
PyMuPDF==1.24.0
pdf2image==1.17.0
pytesseract==0.3.10
Pillow==10.3.0
transformers==4.42.0
sentencepiece==0.2.0
torch==2.2.2
nltk==3.8.1
```

---

### README.md (🔍 原因と修正ポイントまとめ)
```markdown
## ❗ 変換が動かなかった主原因
1. **PyMuPDF API 誤用** – `fitz.TextBlock` は存在しないクラスでした。
2. **画像 size 判定** – `extract_image()` の戻り dict に `size` キーは無く、`len(img['image'])` で判定する必要があります。
3. **巨大テキストの要約** – BART のトークン制限を超えるとクラッシュ。チャンク化で解決。

## 🩹 主な改善
- PDF → Markdown パイプラインを全面再実装（2‑pass 解析で見出し抽出）。
- エラーログとユーザ向け flash メッセージを追加。
- UI を Tailwind + Lucide icons でリファイン。
```

---

### app.py
```python
from flask import Flask, render_template, request, send_file, redirect, url_for, flash
from werkzeug.utils import secure_filename
from pathlib import Path
import uuid, logging
from services.pdf_to_markdown import convert_pdf

# ---------- paths & config ----------
BASE_DIR = Path(__file__).resolve().parent
UPLOAD_DIR = BASE_DIR / "uploads"
OUTPUT_DIR = BASE_DIR / "outputs"
for p in (UPLOAD_DIR, OUTPUT_DIR):
    p.mkdir(exist_ok=True)
ALLOWED_EXT = {".pdf"}

# ---------- logging ----------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.FileHandler(BASE_DIR / "server.log"), logging.StreamHandler()],
)
logger = logging.getLogger(__name__)

# ---------- app ----------
app = Flask(__name__)
app.config["SECRET_KEY"] = "change‑me‑in‑prod"

def allowed(filename: str) -> bool:
    return Path(filename).suffix.lower() in ALLOWED_EXT

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/upload", methods=["POST"])
def upload():
    pdf = request.files.get("pdf")
    if not pdf or pdf.filename == "":
        flash("PDF を選択してください。", "warning")
        return redirect(url_for("index"))
    if not allowed(pdf.filename):
        flash("PDF 形式のみ対応しています。", "danger")
        return redirect(url_for("index"))

    # ---------- save ----------
    file_id = uuid.uuid4().hex
    pdf_path = UPLOAD_DIR / f"{file_id}.pdf"
    pdf.save(pdf_path)
    logger.info("Uploaded %s", pdf_path.name)

    # ---------- convert ----------
    try:
        md_text = convert_pdf(pdf_path)
    except Exception as e:
        logger.exception("Conversion failed: %s", e)
        flash("変換中にエラーが発生しました。PDF が研究論文形式か確認してください。", "danger")
        return redirect(url_for("index"))

    md_path = OUTPUT_DIR / f"{file_id}.md"
    md_path.write_text(md_text, encoding="utf-8")

    flash("変換成功！", "success")
    return render_template("result.html", markdown=md_text, download=url_for("download_md", file_id=file_id))

@app.route("/download/<file_id>")
def download_md(file_id):
    md_path = OUTPUT_DIR / f"{file_id}.md"
    if md_path.exists():
        return send_file(md_path, as_attachment=True)
    flash("ファイルが存在しません。", "danger")
    return redirect(url_for("index"))

if __name__ == "__main__":
    app.run(debug=True, port=5000)
```

---

### services/__init__.py
```python
# Just to mark the folder as a module.
```

---

### services/pdf_to_markdown.py
```python
"""PDF → Markdown conversion pipeline (2‑pass heading detection)."""
from pathlib import Path
import statistics, textwrap, logging
import fitz  # PyMuPDF
from .summarize import summarize_text
from .keywords import extract_keywords
from .ocr_figures import extract_figure_captions

logger = logging.getLogger(__name__)

# ---------- helpers ----------

def _collect_font_sizes(doc):
    sizes = []
    for page in doc:
        for block in page.get_text("dict").get("blocks", []):
            if block.get("type") != 0:
                continue
            for line in block.get("lines", []):
                for span in line.get("spans", []):
                    sizes.append(span["size"])
    return sizes or [11]


def _text_from_block(block_dict):
    return "".join(span["text"] for line in block_dict.get("lines", []) for span in line.get("spans", [])).strip()

# ---------- main ----------

def convert_pdf(pdf_path: Path) -> str:
    logger.info("Converting %s", pdf_path)
    doc = fitz.open(pdf_path)

    # pass‑1: font stats
    body_size = statistics.mode(round(s) for s in _collect_font_sizes(doc))  # most common size
    heading_threshold = body_size + 1  # crude heuristic
    logger.info("Body font ≈ %s pt; heading ≥ %s pt", body_size, heading_threshold)

    # pass‑2: sectioning
    sections = []
    current = {"title": "", "content": ""}

    for page in doc:
        for block in page.get_text("dict").get("blocks", []):
            if block.get("type") != 0:
                continue
            txt = _text_from_block(block)
            if not txt:
                continue
            span_size = block["lines"][0]["spans"][0]["size"]
            if span_size >= heading_threshold and len(txt) < 120:
                if current["title"] or current["content"]:
                    sections.append(current)
                current = {"title": txt, "content": ""}
            else:
                current["content"] += " " + txt
    if current["title"] or current["content"]:
        sections.append(current)

    # Markdown build
    md_lines = []
    full_text = " ".join(sec["content"] for sec in sections)

    # summary & keywords
    summary = summarize_text(full_text)
    md_lines.append("# 論文要約\n" + summary + "\n")
    md_lines.append("**キーワード:** " + ", ".join(extract_keywords(full_text)) + "\n\n")

    for sec in sections:
        if sec["title"]:
            md_lines.append(f"## {sec['title']}")
        md_lines.append(textwrap.fill(sec["content"].strip(), 120))
        md_lines.append("\n")

    # figures
    captions = extract_figure_captions(pdf_path)
    if captions:
        md_lines.append("---\n## 重要図表 OCR キャプション\n")
        md_lines.extend(f"- {c}" for c in captions)

    return "\n".join(md_lines)
```

---

### services/summarize.py
```python
import nltk, textwrap, logging
from transformers import pipeline
nltk.download("punkt", quiet=True)
logger = logging.getLogger(__name__)

try:
    _summarizer = pipeline("summarization", model="facebook/bart-large-cnn", device_map="auto")
except Exception as e:
    logger.warning("transformers pipeline unavailable (%s) – falling back to naive summarizer", e)
    _summarizer = None


def summarize_text(text: str, max_words: int = 120):
    if not text:
        return "(内容が空です)"
    if _summarizer:
        # chunk to avoid token limit
        chunks = nltk.tokenize.sent_tokenize(text)
        half = len(chunks) // 2 or 1
        head = " ".join(chunks[:half])
        return _summarizer(head)[0]["summary_text"]
    # fallback: first few sentences
    return " ".join(chunks[:3])
```

---

### services/keywords.py
```python
import nltk, re
from collections import Counter
nltk.download("stopwords", quiet=True)
STOP = set(nltk.corpus.stopwords.words("english")) | set("の こと など また ため それ これ その".split())

def extract_keywords(text: str, n: int = 8):
    words = re.findall(r"[\w一-龥]{2,}", text.lower())
    cnt = Counter(w for w in words if w not in STOP)
    return [w for w, _ in cnt.most_common(n)]
```

---

### services/ocr_figures.py
```python
from pathlib import Path
import fitz, tempfile
from PIL import Image
import pytesseract, logging

logger = logging.getLogger(__name__)


def extract_figure_captions(pdf_path: Path, max_images: int = 5):
    doc = fitz.open(pdf_path)
    captions = []
    for page in doc:
        for img in page.get_images(full=True):
            xref = img[0]
            base = doc.extract_image(xref)
            if len(base["image"]) < 50_000:
                continue
            with tempfile.NamedTemporaryFile(suffix=".png", delete=True) as tmp:
                tmp.write(base["image"])
                tmp.flush()
                cap = pytesseract.image_to_string(Image.open(tmp.name), lang="eng+jpn").strip()
                if cap:
                    captions.append(cap)
            if len(captions) >= max_images:
                return captions
    return captions
```

---

### templates/base.html
```html
<!DOCTYPE html>
<html lang="ja" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OT Learning Hub</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/lucide@latest"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}" />
</head>
<body class="min-h-screen bg-gradient-to-br from-sky-50 to-indigo-100 flex flex-col">
  <header class="shadow-sm bg-white/80 backdrop-blur sticky top-0 z-50">
    <div class="max-w-5xl mx-auto px-6 py-4 flex items-center gap-3">
      <i data-lucide="book-open" class="w-6 h-6 text-indigo-600"></i>
      <span class="text-xl font-semibold tracking-wide text-slate-800">OT Learning Hub</span>
    </div>
  </header>
  <main class="flex-grow container max-w-5xl mx-auto px-6 py-10">
    {% with msgs = get_flashed_messages(with_categories=true) %}
    {% if msgs %}
      <ul class="space-y-2 mb-6">
        {% for cat, msg in msgs %}
          <li class="px-4 py-2 rounded-lg {{ 'bg-green-100 text-green-800' if cat=='success' else ('bg-red-100 text-red-800' if cat=='danger' else 'bg-yellow-100 text-yellow-800') }}">{{ msg }}</li>
        {% endfor %}
      </ul>
    {% endif %}
    {% endwith %}
    {% block content %}{% endblock %}
  </main>
  <footer class="text-center text-xs py-6 text-slate-600">© {{ now.year }} OT Learning Hub</footer>
  <script>lucide.createIcons();</script>
</body>
</html>
```

---

### templates/index.html
```html
{% extends 'base.html' %}
{% block content %}
<section class="bg-white/90 backdrop-blur shadow-xl rounded-3xl p-10">
  <h2 class="text-2xl font-semibold mb-6 flex items-center gap-2"><i data-lucide="upload"></i> 学術 PDF → Markdown 変換</h2>
  <form action="{{ url_for('upload') }}" method="post" enctype="multipart/form-data" class="space-y-4">
    <input name="pdf" type="file" accept="application/pdf" required class="file:mr-4 file:px-4 file:py-2 file:rounded-lg file:border-0 file:bg-indigo-600 file:text-white hover:file:bg-indigo-700 text-sm text-slate-700" />
    <button type="submit" class="inline-flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg shadow-md"><i data-lucide="play"></i> 変換実行</button>
  </form>
</section>
{% endblock %}
```

---

### templates/result.html
```html
{% extends 'base.html' %}
{% block content %}
<article class="prose max-w-none bg-white/90 backdrop-blur p-8 rounded-3xl shadow-xl">
  <h2 class="flex items-center gap-2"><i data-lucide="file-text"></i> 変換結果</h2>
  <p class="mb-4">
    <a href="{{ download }}" class="text-indigo-600 hover:underline flex items-center gap-1"><i data-lucide="download"></i> Markdown をダウンロード</a>
  </p>
  <pre class="whitespace-pre-wrap overflow-x-auto bg-slate-100/80 p-4 rounded-xl">{{ markdown }}</pre>
</article>
{% endblock %}
```

---

### static/css/style.css
```css
body {font-family: "Inter", "Noto Sans JP", sans-serif;}
```

---

### static/js/main.js
```js
// Reserved for future interactive features.
```

---

```
# ⬆️ END OF FILES
```
